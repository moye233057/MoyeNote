`ˋ`
# coding:utf-8
import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web

from tornado.options import define, options

define("port", default=8000, help="run on the given port", type=int)


class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        greeting = self.get_argument('greeting', 'Hello')
        self.write(greeting + ', welcome you to read: www.itdiffer.com')


if __name__ == "__main__":
    tornado.options.parse_command_line()
    app = tornado.web.Application(handlers=[(r"/", IndexHandler)])
    http_server = tornado.httpserver.HTTPServer(app)
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()
`ˋ`


引入模块
import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web

# tornado.httpserver
这个模块就是用来解决web服务器的http协议问题，它提供了不少属性方法，实现客户端和服务器端的互通。
Tornado的非阻塞、单线程的特点在这个模块中体现。
# tornado.ioloop
这个也非常重要，能够实现非阻塞socket循环，不能互通一次就结束呀。
# tornado.options
这是命令行解析模块，也常用到。
# tornado.web
这是必不可少的模块，它提供了一个简单的Web框架与异步功能，从而使其扩展到大量打开的连接，使其成为理想的长轮询。


# from tornado.options import define, options
# define("port", default=8000, help="run on the given port", type=int)
这两句就显示了所谓“命令行解析模块”的用途了。
在这里通过tornado.options.define()定义了访问本服务器的端口，就是当在浏览器地址栏中输入http:localhost:8000的时候，才能访问本网站，因为http协议默认的端口是80，为了区分，我在这里设置为8000。
为什么要区分呢？因为我的计算机或许你的也是，已经部署了别（或许是Nginx、Apache）服务器了，它的端口是80,所以要区分开（也可能是故意不用80端口），并且，后面我们还会将tornado和Nginx联合起来工作，这样两个服务器在同一台计算机上，就要分开喽。


# 用greeting = self.get_argument('greeting', 'Hello')的方式可以得到url中传递的参数，比如
浏览器输入：http://localhost:8000/?greeting=Qiwsir
Qiwsir, welcome you to read: www.itdiffer.com

self.write(greeting + ',weblcome you to read: www.itdiffer.com)'中，write()方法主要功能是向客户端反馈信息。

tornado.options.parse_command_line(),这是在执行tornado的解析命令行。在tornado的程序中，只要import模块之后，就会在运行的时候自动加载，不需要了解细节，但是，在main（）方法中如果有命令行解析，必须要提前将模块引入。


# Application类
下面这句是重点：
# app = tornado.web.Application(handlers=[(r"/", IndexHandler)])
将tornado.web.Application类实例化。这个实例化，本质上是建立了整个网站程序的请求处理集合，然后它可以被HTTPServer做为参数调用，实现http协议服务器访问。Application类的__init__方法参数形式：
def __init__(self, handlers=None, default_host="", transforms=None,**settings):
    pass
在一般情况下，handlers是不能为空的，因为Application类通过这个参数的值处理所得到的请求。
例如在本例中，handlers=[(r"/", IndexHandler)]，就意味着如果通过浏览器的地址栏输入根路径（http://localhost:8000就是根路径，如果是http://localhost:8000/qiwsir，就不属于根，而是一个子路径或目录了），对应着就是让名字为IndexHandler类处理这个请求。

通过handlers传入的数值格式，一定要注意，在后面做复杂结构的网站是，这里就显得重要了。
它是一个list，list里面的元素是tuple，tuple的组成包括两部分，一部分是请求路径，另外一部分是处理程序的类名称。
注意请求路径可以用正则表达式书写。举例说明：
handlers = [
    (r"/", IndexHandlers),              #来自根路径的请求用IndesHandlers处理
    (r"/qiwsir/(.*)", QiwsirHandlers),  #来自/qiwsir/以及其下任何请求（正则表达式表示任何字符）都由QiwsirHandlers处理
]


# HTTPServer类
实例化之后，Application对象（用app做为标签的）就可以被另外一个类HTTPServer引用，形式为：
# http_server = tornado.httpserver.HTTPServer(app)
HTTPServer是tornado.httpserver里面定义的类。HTTPServer是一个单线程非阻塞HTTP服务器，执行HTTPServer一般要回调Application对象，并提供发送响应的接口,也就是下面的内容是跟随上面语句的
# http_server.listen(options.port)
（options.port的值在IndexHandler类前面通过from...import..设置的）。
这种方法，就建立了单进程的http服务。


# IOLoop类
剩下最后一句了：
# tornado.ioloop.IOLoop.instance().start()
这句话，总是在__main()__的最后一句。表示可以接收来自HTTP的请求了。